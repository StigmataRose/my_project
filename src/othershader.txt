// src/shader.frag.glsl
#version 330 core

uniform vec2 u_resolution;
uniform float u_time;

in vec2 v_tex_coord;
out vec4 out_color;

#define time u_time // FIXED: Use the u_time uniform provided by the C++ host
#define LINES 32
#define STEP 1.0/float(LINES)

#define POINTS 10
#define MAX_POINTS POINTS

const float PI = acos(-1.0);
const float TAU = PI * 2.0;

// Draw helpers
vec2 p;

float line(vec2 a, vec2 b) {
    vec2 v  = b-a;
    vec2 p0 = p-a;
    // Use the clamp logic from your original working version for a well-defined line segment.
    float k = clamp(dot(p0,v)/dot(v,v), 0.0, 1.0);
    // FIXED: Use u_resolution instead of iResolution
    return smoothstep(4.0/u_resolution.y, 0.0, length(p0-k*v));
}

// FIXED: Use u_resolution instead of iResolution
float point(vec2 o) { return smoothstep(10.0/u_resolution.y, 7.5/u_resolution.y, length(p-o)); }

void drawPoint(inout vec3 color, vec3 drawColor, vec2 point_pos) {
    color = mix(color, drawColor, point(point_pos));
}

void drawPoints(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {
    for (int i = 0; i < count; i++)
        drawPoint(color, drawColor, p[i]);
}

// Renamed from drawLine to avoid conflict with the line() helper.
void drawLinePath(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {
    for (int i = 0; i < count - 1; i++) {
        color = mix(color, drawColor, line(p[i], p[i+1]));
    }
}

vec2 splineInterpolation(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {
    float alpha = 1.0;
    float tension = 0.0;
    
    float t01 = pow(distance(p0, p1), alpha);
    float t12 = pow(distance(p1, p2), alpha);
    float t23 = pow(distance(p2, p3), alpha);

    vec2 m1 = (1.0f - tension) *
        (p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));
    vec2 m2 = (1.0f - tension) *
        (p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));
    
    vec2 a = 2.0f * (p1 - p2) + m1 + m2;
    vec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;
    vec2 c = m1;
    vec2 d = p1;

    return a * t * t * t +
           b * t * t +
           c * t +
           d;
}

float spline(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {
    float curve = 0.0;
    vec2 a = p1;

    for (int i = 1; i <= LINES; i++) {
        vec2 b = splineInterpolation(p0, p1, p2, p3, STEP*float(i));
        curve = mix(curve,1.0, line(a, b));
        a = b;
    }
    
    return curve;
}

void drawSpline(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {
    // Need at least 4 points for the Catmull-Rom spline segment.
    if (count < 4) return;
    for (int i = 0; i < count - 3; i++) {
        color = mix(color, drawColor, spline(p[i], p[i+1], p[i+2], p[i+3]));
    }
}

// This function can now return the array directly.
vec2[MAX_POINTS] deformedCircle(int count) {
    vec2 points[MAX_POINTS];
    for (int i = 0; i < count; i++) {
        float a = float(i) / float(count) * TAU;
        // FIXED: Use u_time instead of iTime
        float r = 0.3 + 0.1 * sin(u_time) + 0.15 * sin(a * 3.456 + u_time);
        points[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * r;
    }
    return points;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    // FIXED: Use u_resolution instead of iResolution
    p = (2.0*fragCoord.xy-u_resolution.xy)/u_resolution.y;

    vec3 color = vec3(0.0);
    
    vec2 points[MAX_POINTS] = deformedCircle(POINTS);
    
    drawLinePath(color, vec3(1.0), points, POINTS);
    drawPoints(color, vec3(1.0), points, POINTS);
    
    drawSpline(color, vec3(0.4627, 0.7255, 0.0), points, POINTS);
    
    fragColor = vec4(color, 1.0);
}

// REMOVED: Redundant forward declaration of mainImage is not needed here.

// This is the main entry point for the Visage framework.
// It correctly calls your mainImage function.
void main() {
    vec2 fragCoord = v_tex_coord * u_resolution;
    mainImage(out_color, fragCoord);
}